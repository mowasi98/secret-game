<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- FORCE NO CACHE -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>Secret - Set Up Profile</title>
    
    <!-- Favicons and App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="/logo.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/logo-180.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#6c3aed">
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Game-themed floating emojis -->
        <div class="sparkle" style="top: 8%; left: 12%;">ğŸ”¥</div>
        <div class="sparkle" style="top: 15%; right: 10%; animation-delay: 0.7s;">ğŸŒ¶ï¸</div>
        <div class="sparkle" style="top: 25%; left: 8%; animation-delay: 1.4s;">ğŸ˜œ</div>
        <div class="sparkle" style="top: 35%; right: 15%; animation-delay: 2.1s;">ğŸ‰</div>
        <div class="sparkle" style="top: 45%; left: 5%; animation-delay: 0.9s;">ğŸ’‹</div>
        <div class="sparkle" style="top: 55%; right: 8%; animation-delay: 1.8s;">ğŸ¤«</div>
        <div class="sparkle" style="top: 65%; left: 10%; animation-delay: 2.5s;">ğŸ­</div>
        <div class="sparkle" style="top: 75%; right: 12%; animation-delay: 1.2s;">ğŸ’¥</div>
        <div class="sparkle" style="bottom: 20%; left: 15%; animation-delay: 1.6s;">ğŸ”’</div>
        <div class="sparkle" style="bottom: 30%; right: 18%; animation-delay: 2.3s;">ğŸ˜‹</div>
        <div class="sparkle" style="bottom: 12%; left: 20%; animation-delay: 0.5s;">ğŸ¡</div>
        <div class="sparkle" style="bottom: 8%; right: 22%; animation-delay: 1.1s;">ğŸ’¬</div>

        <div class="page" id="splashScreen">
            <div class="logo">
                <div style="font-size: 6rem;">ğŸ­</div>
                <div class="logo-text">SECRET</div>
            </div>
        </div>

        <div class="page hidden" id="profileSetup">
            <div class="text-bubble">
                Set up your profile so your friends know who's playing!
            </div>

            <input 
                type="text" 
                class="glass-input" 
                id="nameInput" 
                placeholder="Your name" 
                maxlength="20"
            >

            <label for="photoInput" class="profile-upload" id="profileUploadLabel">
                <span class="camera-icon" id="cameraIcon">ğŸ“·</span>
                <img id="profilePreview" style="display: none;" alt="Profile">
                <input type="file" id="photoInput" accept="image/*">
            </label>

            <div class="gender-selector">
                <button class="gender-btn" data-gender="boy">Boy</button>
                <button class="gender-btn" data-gender="girl">Girl</button>
            </div>

            <button class="glass-btn" id="continueBtn" disabled>
                Continue âœ
            </button>
        </div>
    </div>

    <!-- Photo Crop Modal -->
    <div class="crop-modal hidden" id="cropModal">
        <div class="crop-container">
            <h2 style="color: white; margin-bottom: 20px; text-align: center;">Adjust Your Photo</h2>
            
            <div class="crop-canvas-wrapper">
                <canvas id="cropCanvas"></canvas>
                <div class="crop-circle-overlay"></div>
            </div>

            <div class="crop-zoom-controls">
                <button class="zoom-btn" id="zoomOut">âˆ’</button>
                <input type="range" id="zoomSlider" min="100" max="300" value="100" step="1">
                <button class="zoom-btn" id="zoomIn">+</button>
            </div>

            <div class="crop-buttons">
                <button class="glass-btn" id="cancelCrop" style="background: rgba(255,255,255,0.15);">Cancel</button>
                <button class="glass-btn" id="saveCrop">Save Photo</button>
            </div>
        </div>
    </div>

    <!-- About Button (bottom left) -->
    <button class="about-btn" id="aboutBtn">
        â„¹ï¸ What's this game about?
    </button>

    <!-- About Popup (hidden by default) -->
    <div class="about-popup hidden" id="aboutPopup">
        <button class="about-close" id="aboutClose">âœ•</button>
        <div style="font-size: 1.3rem; font-weight: 700; margin-bottom: 12px;">ğŸ­ About Secret</div>
        <p style="margin: 0; line-height: 1.5;">
            The ultimate party game for friends!<br>
            Answer spicy questions, vote anonymously,<br>
            and spin the wheel for dares & challenges.
        </p>
        <p style="margin: 10px 0 0 0; line-height: 1.5;">
            Perfect for parties, gatherings, and fun nights!
        </p>
        <p style="margin: 10px 0 0 0; font-weight: 600; color: #ffc107;">
            Ages 18+ â€¢ 3-10 players<br>
            ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Family Mode available (Ages 10+)
        </p>
    </div>

    <script>
        // About popup toggle
        document.getElementById('aboutBtn').addEventListener('click', () => {
            document.getElementById('aboutPopup').classList.remove('hidden');
        });
        document.getElementById('aboutClose').addEventListener('click', () => {
            document.getElementById('aboutPopup').classList.add('hidden');
        });
    </script>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // VERSION CHECK
        console.log('%cğŸ® SECRET GAME - LOGIN PAGE', 'color: #6c3aed; font-size: 18px; font-weight: bold;');
        console.log('%cVersion: v2.5.0', 'color: #2d5cf6; font-size: 14px;');
        
        const socket = io();

        let profileData = {
            name: '',
            photo: '',
            gender: ''
        };

        // Splash screen transition
        setTimeout(() => {
            document.getElementById('splashScreen').classList.add('hidden');
            document.getElementById('profileSetup').classList.remove('hidden');
        }, 2000);

        // Photo upload with circular cropper
        const photoInput = document.getElementById('photoInput');
        const profilePreview = document.getElementById('profilePreview');
        const cameraIcon = document.getElementById('cameraIcon');

        // Photo Cropper Variables
        let cropperImage = null;
        let cropCanvas = null;
        let cropCtx = null;
        let imageX = 0;
        let imageY = 0;
        let imageScale = 1;
        let initialScale = 1;
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let canvasSize = 0;
        
        photoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    cropperImage = new Image();
                    cropperImage.onload = function() {
                        openCropper();
                    };
                    cropperImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        function openCropper() {
            document.getElementById('cropModal').classList.remove('hidden');
            
            cropCanvas = document.getElementById('cropCanvas');
            cropCtx = cropCanvas.getContext('2d');
            
            const isMobile = window.innerWidth <= 768;
            canvasSize = isMobile ? Math.min(window.innerWidth * 0.75, 350) : 400;
            cropCanvas.width = canvasSize;
            cropCanvas.height = canvasSize;
            
            // Calculate initial scale to fit image in canvas
            const imgAspect = cropperImage.width / cropperImage.height;
            if (imgAspect > 1) {
                initialScale = canvasSize / cropperImage.height;
            } else {
                initialScale = canvasSize / cropperImage.width;
            }
            
            imageScale = initialScale;
            imageX = (canvasSize - cropperImage.width * imageScale) / 2;
            imageY = (canvasSize - cropperImage.height * imageScale) / 2;
            
            document.getElementById('zoomSlider').value = 100;
            drawCropper();
            setupCropperControls();
        }

        function drawCropper() {
            // Clear canvas
            cropCtx.clearRect(0, 0, canvasSize, canvasSize);
            
            // Draw the full image (freely movable)
            const imgWidth = cropperImage.width * imageScale;
            const imgHeight = cropperImage.height * imageScale;
            cropCtx.drawImage(cropperImage, imageX, imageY, imgWidth, imgHeight);
            
            // Draw dark overlay ONLY outside the circle using path clipping
            cropCtx.save();
            cropCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            
            // Create a path that covers everything EXCEPT the circle
            cropCtx.beginPath();
            // Outer rectangle (entire canvas)
            cropCtx.rect(0, 0, canvasSize, canvasSize);
            // Inner circle (hole) - counter-clockwise to subtract
            cropCtx.arc(canvasSize / 2, canvasSize / 2, canvasSize / 2 - 20, 0, Math.PI * 2, true);
            // Fill using even-odd rule (creates hole)
            cropCtx.fill('evenodd');
            
            cropCtx.restore();
        }

        function setupCropperControls() {
            let lastTouchDistance = 0;
            
            cropCanvas.addEventListener('mousedown', startDrag);
            cropCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling/zooming on touch
                if (e.touches.length === 2) {
                    lastTouchDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                } else {
                    startDrag(e);
                }
            }, { passive: false });
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault(); // Prevent page zoom during pinch
                    const touchDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    const delta = touchDistance - lastTouchDistance;
                    const slider = document.getElementById('zoomSlider');
                    const newZoom = Math.max(100, Math.min(300, parseInt(slider.value) + delta * 0.3));
                    slider.value = newZoom;
                    handleZoom({ target: { value: newZoom } });
                    lastTouchDistance = touchDistance;
                } else {
                    drag(e);
                }
            }, { passive: false });
            
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
            
            document.getElementById('zoomSlider').addEventListener('input', handleZoom);
            document.getElementById('zoomIn').addEventListener('click', () => {
                const slider = document.getElementById('zoomSlider');
                slider.value = Math.min(300, parseInt(slider.value) + 10);
                handleZoom({ target: slider });
            });
            document.getElementById('zoomOut').addEventListener('click', () => {
                const slider = document.getElementById('zoomSlider');
                slider.value = Math.max(100, parseInt(slider.value) - 10);
                handleZoom({ target: slider });
            });
            
            document.getElementById('saveCrop').onclick = saveCroppedImage;
            document.getElementById('cancelCrop').onclick = () => {
                document.getElementById('cropModal').classList.add('hidden');
                photoInput.value = '';
            };
        }

        function startDrag(e) {
            isDragging = true;
            const rect = cropCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            startX = clientX - rect.left - imageX;
            startY = clientY - rect.top - imageY;
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();
            const rect = cropCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Complete freedom - no boundaries!
            imageX = clientX - rect.left - startX;
            imageY = clientY - rect.top - startY;
            
            drawCropper();
        }

        function stopDrag() {
            isDragging = false;
        }

        function handleZoom(e) {
            const zoomPercent = parseInt(e.target.value);
            const oldScale = imageScale;
            imageScale = initialScale * (zoomPercent / 100);
            
            // Keep zoom centered on canvas center
            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;
            const scaleDiff = imageScale / oldScale;
            
            imageX = centerX - (centerX - imageX) * scaleDiff;
            imageY = centerY - (centerY - imageY) * scaleDiff;
            
            drawCropper();
        }

        function saveCroppedImage() {
            // Create output canvas for the cropped circular image
            const outputCanvas = document.createElement('canvas');
            const outputSize = 400;
            outputCanvas.width = outputSize;
            outputCanvas.height = outputSize;
            const outputCtx = outputCanvas.getContext('2d');
            
            // Calculate the crop area from the canvas
            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;
            const radius = canvasSize / 2 - 20;
            
            // Calculate scale factor from crop circle to output size
            const scale = outputSize / (radius * 2);
            
            // Create circular clipping path
            outputCtx.save();
            outputCtx.beginPath();
            outputCtx.arc(outputSize / 2, outputSize / 2, outputSize / 2, 0, Math.PI * 2);
            outputCtx.clip();
            
            // Calculate source position for the crop
            const srcX = (imageX - (centerX - radius)) * scale;
            const srcY = (imageY - (centerY - radius)) * scale;
            const srcWidth = cropperImage.width * imageScale * scale;
            const srcHeight = cropperImage.height * imageScale * scale;
            
            // Draw the cropped portion
            outputCtx.drawImage(cropperImage, srcX, srcY, srcWidth, srcHeight);
            outputCtx.restore();
            
            // Convert to base64
            const croppedImage = outputCanvas.toDataURL('image/jpeg', 0.7);
            
            // Update profile
            profileData.photo = croppedImage;
            profilePreview.src = croppedImage;
            profilePreview.style.display = 'block';
            cameraIcon.style.display = 'none';
            
            // Close modal
            document.getElementById('cropModal').classList.add('hidden');
            checkFormComplete();
        }

        // Name input
        document.getElementById('nameInput').addEventListener('input', (e) => {
            profileData.name = e.target.value.trim();
            checkFormComplete();
        });

        // Gender selection
        document.querySelectorAll('.gender-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.gender-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                profileData.gender = btn.dataset.gender;
                checkFormComplete();
            });
        });

        // Check if form is complete
        function checkFormComplete() {
            const isComplete = profileData.name && profileData.photo && profileData.gender;
            document.getElementById('continueBtn').disabled = !isComplete;
        }

        // Continue button
        document.getElementById('continueBtn').addEventListener('click', () => {
            // Send profile to server
            socket.emit('set-profile', profileData);
            
            // Store in localStorage
            localStorage.setItem('secretProfile', JSON.stringify(profileData));
            
            // Redirect to main menu
            window.location.href = '/menu.html';
        });

        // Check if profile already exists and pre-fill (but still show splash)
        const savedProfile = localStorage.getItem('secretProfile');
        if (savedProfile) {
            const profile = JSON.parse(savedProfile);
            
            // Pre-fill data when profile setup appears
            setTimeout(() => {
                profileData = profile;
                document.getElementById('nameInput').value = profile.name;
                profilePreview.src = profile.photo;
                profilePreview.style.display = 'block';
                cameraIcon.style.display = 'none';
                
                const genderBtn = document.querySelector(`[data-gender="${profile.gender}"]`);
                if (genderBtn) genderBtn.classList.add('selected');
                
                checkFormComplete();
            }, 2100); // After splash screen
        }
    </script>
</body>
</html>
