 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- FORCE NO CACHE -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>Secret - Game</title>
    
    <!-- Favicons and App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="/logo.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/logo-180.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#6c3aed">
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="close-btn" id="leaveGameBtn">‚úñ</div>

        <!-- Wheel Mode: Input Phase (One at a time) -->
        <div class="page hidden" id="wheelInputPage">
            <div class="text-bubble" id="wheelInstructionText">
                Fill out this prompt anonymously
            </div>

            <div class="prompt-label" id="wheelPromptLabel">1. üîç Personal Question</div>
            <textarea 
                class="glass-textarea" 
                id="wheelCurrentInput" 
                placeholder="Ask a personal question about someone..."
                maxlength="200"
            ></textarea>

            <button class="glass-btn" id="wheelNextBtn" disabled>
                Next ‚ûú
            </button>
        </div>

        <!-- Waiting for others -->
        <div class="page hidden" id="waitingPage">
            <div class="waiting-screen">
                <div class="waiting-spinner">‚è≥</div>
                <div class="waiting-text" id="waitingText">Waiting for everyone else...</div>
                <div class="waiting-progress" id="waitingProgress">0/0 submitted</div>
            </div>
        </div>

        <!-- Wheel Mode: Spinning Phase -->
        <div class="page hidden" id="wheelSpinPage">
            <div style="position: absolute; top: 20px; right: 20px; background: rgba(108, 58, 237, 0.3); padding: 10px 20px; border-radius: 15px; font-weight: 700; font-size: 1.1rem; border: 2px solid rgba(108, 58, 237, 0.5);" id="wheelCounter">
                1 / 40
            </div>

            <div class="text-bubble" id="wheelStatusText">
                Time to spin the wheel!
            </div>

            <div class="wheel-container">
                <div class="wheel-pointer">‚ñº</div>
                <div class="wheel" id="wheel">
                    <svg width="100%" height="100%" viewBox="0 0 400 400">
                        <defs>
                            <!-- Gradients for premium look -->
                            <linearGradient id="dareGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#e94b9b;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#d6287f;stop-opacity:1" />
                            </linearGradient>
                            <linearGradient id="personalGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#6c3aed;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#5221d1;stop-opacity:1" />
                            </linearGradient>
                            <linearGradient id="gossipGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#2d5cf6;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#1a3fd9;stop-opacity:1" />
                            </linearGradient>
                            <linearGradient id="secretGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#7c3aed;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#6221d1;stop-opacity:1" />
                            </linearGradient>
                            <!-- Shadow filter -->
                            <filter id="innerShadow">
                                <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                                <feOffset dx="0" dy="0" result="offsetblur"/>
                                <feFlood flood-color="#000000" flood-opacity="0.3"/>
                                <feComposite in2="offsetblur" operator="in"/>
                                <feMerge>
                                    <feMergeNode/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                        </defs>
                        <g transform="translate(200, 200)">
                            <!-- 4 Segments: Alternating PERSONAL and GOSSIP -->
                            
                            <!-- Segment 1: PERSONAL (0-90¬∞, top-right quarter) -->
                            <path d="M 0,-170 A 170,170 0 0,1 170,0 L 0,0 Z" fill="url(#personalGrad)" stroke="#1a1a2e" stroke-width="3" filter="url(#innerShadow)"/>
                            <g transform="rotate(45)">
                                <text x="0" y="-85" fill="white" font-size="18" font-weight="900" font-family="Poppins" text-anchor="middle" letter-spacing="1">üîç</text>
                                <text x="0" y="-65" fill="white" font-size="14" font-weight="800" font-family="Poppins" text-anchor="middle">PERSONAL</text>
                            </g>
                            
                            <!-- Segment 2: GOSSIP (90-180¬∞, bottom-right quarter) -->
                            <path d="M 170,0 A 170,170 0 0,1 0,170 L 0,0 Z" fill="url(#gossipGrad)" stroke="#1a1a2e" stroke-width="3" filter="url(#innerShadow)"/>
                            <g transform="rotate(135)">
                                <text x="0" y="-85" fill="white" font-size="18" font-weight="900" font-family="Poppins" text-anchor="middle" letter-spacing="1">üí¨</text>
                                <text x="0" y="-65" fill="white" font-size="14" font-weight="800" font-family="Poppins" text-anchor="middle">GOSSIP</text>
                            </g>
                            
                            <!-- Segment 3: PERSONAL (180-270¬∞, bottom-left quarter) -->
                            <path d="M 0,170 A 170,170 0 0,1 -170,0 L 0,0 Z" fill="url(#personalGrad)" stroke="#1a1a2e" stroke-width="3" filter="url(#innerShadow)"/>
                            <g transform="rotate(225)">
                                <text x="0" y="-85" fill="white" font-size="18" font-weight="900" font-family="Poppins" text-anchor="middle" letter-spacing="1">üîç</text>
                                <text x="0" y="-65" fill="white" font-size="14" font-weight="800" font-family="Poppins" text-anchor="middle">PERSONAL</text>
                            </g>
                            
                            <!-- Segment 4: GOSSIP (270-360¬∞, top-left quarter) -->
                            <path d="M -170,0 A 170,170 0 0,1 0,-170 L 0,0 Z" fill="url(#gossipGrad)" stroke="#1a1a2e" stroke-width="3" filter="url(#innerShadow)"/>
                            <g transform="rotate(315)">
                                <text x="0" y="-85" fill="white" font-size="18" font-weight="900" font-family="Poppins" text-anchor="middle" letter-spacing="1">üí¨</text>
                                <text x="0" y="-65" fill="white" font-size="14" font-weight="800" font-family="Poppins" text-anchor="middle">GOSSIP</text>
                            </g>
                            
                            <!-- Center circle -->
                            <circle cx="0" cy="0" r="50" fill="#1a1a2e" stroke="#6c3aed" stroke-width="3"/>
                            <circle cx="0" cy="0" r="45" fill="url(#personalGrad)"/>
                            <text x="0" y="8" fill="white" font-size="18" font-weight="900" text-anchor="middle" font-family="Poppins">SPIN</text>
                        </g>
                    </svg>
                </div>
            </div>

            <button class="glass-btn hidden" id="spinWheelBtn">
                üé° Spin the Wheel
            </button>

            <div class="text-bubble hidden" id="wheelResult" style="background: white; color: #333; margin-top: 20px;">
                <div style="font-size: 1.5rem; font-weight: bold; margin-bottom: 10px;" id="resultType"></div>
                <div style="font-size: 1.2rem;" id="resultContent"></div>
            </div>

            <button class="glass-btn hidden" id="nextSpinBtn">
                Spin Again
            </button>
        </div>

        <!-- Question Mode: Question Display -->
        <div class="page hidden" id="questionPage">
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="font-size: 1.2rem; opacity: 0.9;" id="questionCounter">Question 1/20</div>
            </div>

            <div class="question-display" id="questionText">
                Who would do this?
            </div>

            <!-- Two player options to vote for -->
            <div class="player-vote-options">
                <div class="player-vote-card" id="playerOption1">
                    <img class="player-vote-avatar" id="playerAvatar1" alt="Player 1">
                    <div class="player-vote-name" id="playerName1">Player 1</div>
                </div>
                
                <div class="vs-text">VS</div>

                <div class="player-vote-card" id="playerOption2">
                    <img class="player-vote-avatar" id="playerAvatar2" alt="Player 2">
                    <div class="player-vote-name" id="playerName2">Player 2</div>
                </div>
            </div>
        </div>

        <!-- Vote Confirmation -->
        <div class="page hidden" id="confirmationPage">
            <div class="vote-confirmation">
                <div class="confirmation-emoji">ü§ê</div>
                <div class="confirmation-text">Your vote is secret this time!</div>
                <div class="confirmation-subtext">
                    No one knows what you picked... but the next question might reveal who voted!
                </div>
            </div>
        </div>

        <!-- Results Page -->
        <div class="page hidden" id="resultsPage">
            <div style="text-align: center; margin-bottom: 20px;">
                <div id="voteBadgeResults" class="hidden"></div>
            </div>
            <div class="poll-results">
                <div class="player-vote-results">
                    <div class="result-player-card">
                        <img class="result-avatar" id="resultAvatar1" alt="Player 1">
                        <div class="result-name" id="resultName1">Player 1</div>
                        <div class="result-percentage" id="resultPercent1">0%</div>
                        <div class="result-count" id="resultCount1">0 votes</div>
                    </div>

                    <div class="result-player-card">
                        <img class="result-avatar" id="resultAvatar2" alt="Player 2">
                        <div class="result-name" id="resultName2">Player 2</div>
                        <div class="result-percentage" id="resultPercent2">0%</div>
                        <div class="result-count" id="resultCount2">0 votes</div>
                    </div>
                </div>

                <div class="vote-details hidden" id="voteDetails">
                    <div class="vote-category">
                        <div class="vote-category-title">Voted for <span id="votedForName1"></span></div>
                        <div class="voter-grid" id="voters1"></div>
                    </div>

                    <div class="vote-category">
                        <div class="vote-category-title">Voted for <span id="votedForName2"></span></div>
                        <div class="voter-grid" id="voters2"></div>
                    </div>
                </div>
            </div>

            <!-- Status text for results page -->
            <div id="resultsStatusText" style="text-align: center; margin: 25px 0 15px 0; font-size: 1.1rem; color: rgba(255, 255, 255, 0.8); font-weight: 500;">
                <!-- Will be filled by JavaScript -->
            </div>

            <button class="glass-btn hidden" id="nextQuestionBtn">
                Next Question ‚ûú
            </button>
        </div>

        <!-- Spicy Special: Who's your type? -->
        <div class="page hidden" id="crushPage">
            <div class="text-bubble" style="font-size: 1.8rem; margin-bottom: 15px;">
                Who's your type?
            </div>

            <div class="text-bubble" style="font-size: 1rem; background: rgba(108, 58, 237, 0.3); margin-bottom: 10px;">
                üîí This question is only for you. No one will see your vote.
            </div>

            <div class="text-bubble" style="font-size: 0.95rem; background: rgba(255, 193, 7, 0.25); margin-bottom: 30px;">
                ‚ö†Ô∏è You must answer to continue. The game won't end until everyone votes.
            </div>

            <div class="voter-grid" id="crushOptions" style="margin: 30px 0;">
                <!-- Player options will be added here -->
            </div>

            <button class="glass-btn" id="submitCrushBtn" disabled>
                Submit (Anonymous)
            </button>
        </div>

        <!-- Game Finished -->
        <div class="page hidden" id="finishedPage">
            <div class="text-bubble" style="font-size: 2.5rem; margin-bottom: 20px;">
                üéâ Game Over! üéâ
            </div>

            <div class="text-bubble" style="font-size: 1.2rem; margin-bottom: 40px;">
                What's next?
            </div>

            <button class="glass-btn" id="playAgainBtn" style="margin-bottom: 20px;">
                üîÑ Play Again (Same Party)
            </button>

            <button class="glass-btn" id="newPartyBtn">
                üÜï New Party
            </button>
        </div>
    </div>

    <script src="modal.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // VERSION CHECK - Look for this in console (F12)
        const APP_VERSION = 'v2.9.6';
        console.log('%cüéÆ SECRET GAME LOADED', 'color: #6c3aed; font-size: 20px; font-weight: bold;');
        console.log('%cVersion: ' + APP_VERSION, 'color: #2d5cf6; font-size: 16px; font-weight: bold;');
        console.log('%cLast Update: Track used questions per party - no repeats across games', 'color: #999; font-size: 12px;');
        console.log('-----------------------------------');
        
        const socket = io();

        // Handle page visibility (phone background/lock)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && socket.connected) {
                // Page came back to foreground, rejoin game to sync
                console.log('Page visible again, resyncing...');
                socket.emit('join-game', { gameCode });
                
                // Request current game state
                socket.emit('request-game-state', { gameCode });
            }
        });
        const gameCode = localStorage.getItem('currentGameCode');
        const profile = JSON.parse(localStorage.getItem('secretProfile'));
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode');

        if (!gameCode || !profile) {
            window.location.href = '/';
        }

        socket.emit('set-profile', profile);
        
        // Join the game room
        socket.emit('join-game', { gameCode, player: profile });

        let isAdmin = false;
        let currentGame = null;
        let hasVoted = false;
        let selectedCrush = null;
        let currentPlayers = [];
        let isAnonymousVote = false;
        let isShowingResults = false; // Flag to prevent waiting page from showing during results
        let lastVoteProgress = { voted: 0, total: 0 }; // Store last vote progress

        // Sound Effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTickSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
        }

        function playDrumRoll() {
            const duration = 2;
            const interval = 0.05;
            let time = 0;
            
            const rollInterval = setInterval(() => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 100 + Math.random() * 50;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
                
                time += interval;
                if (time >= duration) {
                    clearInterval(rollInterval);
                }
            }, interval * 1000);
        }

        function playSuccessSound() {
            // Play ascending notes for success
            const frequencies = [523.25, 659.25, 783.99];
            frequencies.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = freq;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + (index * 0.1);
                gainNode.gain.setValueAtTime(0.3, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.3);
            });
        }

        // We'll load game start data after socket listeners are set up

        // Initialize based on mode
        if (mode === 'wheel') {
            document.getElementById('wheelInputPage').classList.remove('hidden');
            
            let wheelStep = 0;
            const wheelSubmissions = [];
            const wheelPrompts = [
                { emoji: 'üîç', title: 'Personal Question', placeholder: 'Ask a personal question about someone...', type: 'personal' },
                { emoji: 'üí¨', title: 'Gossip', placeholder: 'Share some recent gossip...', type: 'gossip' }
            ];

            function showWheelPrompt() {
                const prompt = wheelPrompts[wheelStep];
                document.getElementById('wheelPromptLabel').textContent = `${wheelStep + 1}. ${prompt.emoji} ${prompt.title}`;
                document.getElementById('wheelCurrentInput').placeholder = prompt.placeholder;
                document.getElementById('wheelCurrentInput').value = '';
                document.getElementById('wheelNextBtn').disabled = true;
                
                if (wheelStep === wheelPrompts.length - 1) {
                    document.getElementById('wheelNextBtn').textContent = 'Submit ‚úì';
                }
            }

            // Enable next button when input filled
            document.getElementById('wheelCurrentInput').addEventListener('input', (e) => {
                document.getElementById('wheelNextBtn').disabled = e.target.value.trim().length === 0;
            });

            // Next button click
            document.getElementById('wheelNextBtn').addEventListener('click', () => {
                const content = document.getElementById('wheelCurrentInput').value.trim();
                const prompt = wheelPrompts[wheelStep];
                
                wheelSubmissions.push({
                    type: prompt.type,
                    content: content
                });

                wheelStep++;

                if (wheelStep < wheelPrompts.length) {
                    // Show next prompt
                    showWheelPrompt();
                } else {
                    // All done, submit
                    socket.emit('submit-wheel-inputs', { gameCode, submissions: wheelSubmissions });
                    
                    document.getElementById('wheelInputPage').classList.add('hidden');
                    
                    const waitingPage = document.getElementById('waitingPage');
                    waitingPage.classList.remove('hidden');
                    // Clear ALL inline styles to show it properly
                    waitingPage.style.display = '';
                    waitingPage.style.visibility = '';
                    waitingPage.style.opacity = '';
                }
            });

            // Show first prompt
            showWheelPrompt();
        } else {
            document.getElementById('questionPage').classList.remove('hidden');
        }

        // Wheel submission status
        socket.on('wheel-submission-status', (data) => {
            document.getElementById('waitingProgress').textContent = 
                `${data.submitted}/${data.total} submitted`;
        });

        let wheelTotalQuestions = 0;
        let wheelCurrentQuestion = 0;

        // Wheel ready
        socket.on('wheel-ready', () => {
            isShowingResults = false; // Reset flag for wheel mode
            
            // Hide waiting page explicitly
            const waitingPage = document.getElementById('waitingPage');
            waitingPage.classList.add('hidden');
            waitingPage.style.display = 'none';
            
            // Show wheel page (clear inline styles)
            const wheelPage = document.getElementById('wheelSpinPage');
            wheelPage.classList.remove('hidden');
            wheelPage.style.display = 'block';
            
            // Admin can spin
            if (isAdmin) {
                document.getElementById('spinWheelBtn').classList.remove('hidden');
            }
        });

        // Function to animate wheel spin (used by all players)
        function animateWheelSpin(rotation) {
            document.getElementById('spinWheelBtn').classList.add('hidden');
            document.getElementById('wheelStatusText').textContent = 'üé° Spinning...';
            
            // Spin animation with exact rotation from server
            const wheel = document.getElementById('wheel');
            wheel.style.transform = `rotate(${rotation}deg)`;
            
            // Play ticking sounds during spin (4 seconds)
            let tickCount = 0;
            const maxTicks = 40;
            const tickInterval = setInterval(() => {
                playTickSound();
                tickCount++;
                if (tickCount >= maxTicks) {
                    clearInterval(tickInterval);
                }
            }, 100);
        }
        
        // Spin wheel button (admin only triggers server event)
        document.getElementById('spinWheelBtn').addEventListener('click', () => {
            socket.emit('spin-wheel', { gameCode });
        });

        // Listen for wheel spinning event (ALL players see this)
        socket.on('wheel-spinning', (data) => {
            animateWheelSpin(data.rotation);
        });

        // Wheel result
        socket.on('wheel-result', (data) => {
            // Update counter
            if (wheelTotalQuestions === 0) {
                wheelTotalQuestions = data.remaining + 1; // Set total on first result
            }
            wheelCurrentQuestion = wheelTotalQuestions - data.remaining;
            document.getElementById('wheelCounter').textContent = `${wheelCurrentQuestion} / ${wheelTotalQuestions}`;

            // Play drum roll after wheel stops (at 3.5 seconds)
            setTimeout(() => {
                document.getElementById('wheelStatusText').textContent = 'ü•Å Drum roll...';
                playDrumRoll();
            }, 3500);
            
            // Show result after drum roll (at 6 seconds total)
            setTimeout(() => {
                const typeEmojis = {
                    personal: 'üîç',
                    gossip: 'üí¨'
                };

                const typeNames = {
                    personal: 'Personal Question',
                    gossip: 'Gossip'
                };

                // Play success sound
                playSuccessSound();
                
                document.getElementById('wheelStatusText').textContent = 'üéâ Result!';
                document.getElementById('resultType').textContent = 
                    `${typeEmojis[data.type]} ${typeNames[data.type]}`;
                document.getElementById('resultContent').textContent = data.content;
                document.getElementById('wheelResult').classList.remove('hidden');
                
                if (isAdmin && data.remaining > 0) {
                    document.getElementById('nextSpinBtn').classList.remove('hidden');
                } else if (data.remaining === 0) {
                    setTimeout(() => {
                        document.getElementById('wheelSpinPage').classList.add('hidden');
                        const finishedPage = document.getElementById('finishedPage');
                        finishedPage.classList.remove('hidden');
                        finishedPage.style.display = 'block'; // Override inline display:none
                    }, 5000);
                }
            }, 6000);
        });

        // Function to reset wheel (used by all players)
        function resetWheel() {
            document.getElementById('wheelResult').classList.add('hidden');
            document.getElementById('nextSpinBtn').classList.add('hidden');
            document.getElementById('wheelStatusText').textContent = 'Time to spin the wheel!';
            
            // Reset wheel rotation
            const wheel = document.getElementById('wheel');
            wheel.style.transition = 'none';
            wheel.style.transform = 'rotate(0deg)';
            setTimeout(() => {
                wheel.style.transition = 'transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
            }, 50);
            
            if (isAdmin) {
                document.getElementById('spinWheelBtn').classList.remove('hidden');
            }
        }

        document.getElementById('nextSpinBtn').addEventListener('click', () => {
            // Admin broadcasts reset to everyone
            socket.emit('reset-wheel', { gameCode });
        });

        // All players listen for wheel reset
        socket.on('wheel-reset', () => {
            resetWheel();
        });

        // Question mode: Game started
        socket.on('game-started', (data) => {
            isShowingResults = false; // Reset flag for new game
            
            // Hide waiting page completely
            const waitingPage = document.getElementById('waitingPage');
            waitingPage.classList.add('hidden');
            waitingPage.style.display = 'none';
            
            // Clear results status text
            document.getElementById('resultsStatusText').textContent = '';
            
            // Show question page (clear inline styles)
            const questionPage = document.getElementById('questionPage');
            questionPage.classList.remove('hidden');
            questionPage.style.display = 'block';
            displayQuestion(data);
        });

        socket.on('next-question', (data) => {
            hasVoted = false;
            isShowingResults = false; // Reset flag for new question
            
            // Hide all other pages with explicit display:none
            document.getElementById('resultsPage').classList.add('hidden');
            
            const waitingPage = document.getElementById('waitingPage');
            waitingPage.classList.add('hidden');
            waitingPage.style.display = 'none';
            
            document.getElementById('confirmationPage').classList.add('hidden');
            
            // Clear results status text
            document.getElementById('resultsStatusText').textContent = '';
            
            // Show question page (clear inline styles from nuclear hide)
            const questionPage = document.getElementById('questionPage');
            questionPage.classList.remove('hidden');
            questionPage.style.display = 'block';
            displayQuestion(data);
        });

        // Vote progress updates
        socket.on('vote-progress', (data) => {
            console.log('üìä Vote progress received:', data);
            
            // Store vote progress for later use
            lastVoteProgress = data;
            
            // ONLY update if NOT showing results and waiting page is visible
            const waitingPage = document.getElementById('waitingPage');
            const resultsPage = document.getElementById('resultsPage');
            
            if (!isShowingResults && !waitingPage.classList.contains('hidden') && resultsPage.classList.contains('hidden')) {
                document.getElementById('waitingProgress').textContent = 
                    `${data.voted}/${data.total} voted`;
                
                console.log(`‚úÖ Updated progress: ${data.voted}/${data.total}`);
                
                // Play a subtle tick sound for each vote
                playTickSound();
            } else {
                console.log('‚ö†Ô∏è Skipped progress update (showing results or waiting hidden)');
            }
        });

        // Handle game join response (including rejoin after phone lock)
        socket.on('game-joined', (data) => {
            console.log('Joined game successfully:', data);
            currentGame = data.game;
            isAdmin = data.game.adminId === socket.id;
            
            // If rejoining an active game, resync the UI
            if (data.game.status === 'playing' && data.game.questions && data.game.currentQuestionIndex >= 0) {
                const currentQ = data.game.questions[data.game.currentQuestionIndex];
                const isAnonymous = !currentQ.isPublic;
                
                // Find the two players being voted on
                if (data.game.currentVotingPlayers && data.game.currentVotingPlayers.length === 2) {
                    const player1 = data.game.currentVotingPlayers[0];
                    const player2 = data.game.currentVotingPlayers[1];
                    
                    // Display the current question
                    displayQuestion({
                        mode: data.game.mode,
                        question: currentQ.text || currentQ,
                        questionNumber: data.game.currentQuestionIndex + 1,
                        totalQuestions: data.game.questions.length,
                        isAnonymous: isAnonymous,
                        players: [player1, player2]
                    });
                    
                    // Check if this player already voted
                    const currentVotes = data.game.votes[data.game.currentQuestionIndex] || {};
                    if (currentVotes[socket.id]) {
                        hasVoted = true;
                        document.getElementById('playerOption1').style.pointerEvents = 'none';
                        document.getElementById('playerOption2').style.pointerEvents = 'none';
                        document.getElementById('playerOption1').style.opacity = '0.5';
                        document.getElementById('playerOption2').style.opacity = '0.5';
                    }
                    
                    console.log('‚úÖ Resynced to current question after reconnect');
                }
            }
            
            // If rejoining wheel mode, sync to current wheel state
            if ((data.game.status === 'wheel-ready' || data.game.status === 'wheel-input') && data.game.currentWheelRotation) {
                console.log('üé° Syncing to wheel rotation:', data.game.currentWheelRotation);
                document.getElementById('waitingPage').classList.add('hidden');
                document.getElementById('wheelSpinPage').classList.remove('hidden');
                
                // Apply current rotation
                const wheel = document.getElementById('wheel');
                wheel.style.transform = `rotate(${data.game.currentWheelRotation}deg)`;
                
                console.log('‚úÖ Resynced to current wheel after reconnect');
            }
        });

        // Load game start data from localStorage after listeners are set up
        const gameStartData = localStorage.getItem('gameStartData');
        if (gameStartData && mode !== 'wheel') {
            const data = JSON.parse(gameStartData);
            console.log('Loading game start data from localStorage:', data);
            localStorage.removeItem('gameStartData'); // Clear it after using
            
            // Display the first question immediately
            setTimeout(() => {
                displayQuestion(data);
                document.getElementById('questionPage').classList.remove('hidden');
            }, 100);
        }

        // Error handling
        socket.on('error', (message) => {
            console.error('Socket error:', message);
            showError(message);
        });

        function displayQuestion(data) {
            console.log('Display question data:', data);
            console.log('Players:', data.players);
            
            currentPlayers = data.players;
            isAnonymousVote = data.isAnonymous;  // Store for results screen
            
            document.getElementById('questionCounter').textContent = 
                `Question ${data.questionNumber}/${data.totalQuestions}`;
            
            document.getElementById('questionText').textContent = data.question;

            // Display two players
            if (data.players && data.players[0] && data.players[1]) {
                document.getElementById('playerAvatar1').src = data.players[0].photo || '';
                document.getElementById('playerName1').textContent = data.players[0].name || 'Player 1';
                
                document.getElementById('playerAvatar2').src = data.players[1].photo || '';
                document.getElementById('playerName2').textContent = data.players[1].name || 'Player 2';
                
                console.log('Player 1:', data.players[0].name, data.players[0].photo);
                console.log('Player 2:', data.players[1].name, data.players[1].photo);
            } else {
                console.error('Players data is missing!', data);
            }
        }

        // Vote for player cards
        document.getElementById('playerOption1').addEventListener('click', () => {
            if (!hasVoted && currentPlayers[0]) {
                vote(currentPlayers[0].id);
            }
        });

        document.getElementById('playerOption2').addEventListener('click', () => {
            if (!hasVoted && currentPlayers[1]) {
                vote(currentPlayers[1].id);
            }
        });

        function vote(playerId) {
            if (hasVoted) return;
            hasVoted = true;

            // Play a quick confirmation sound
            playTickSound();
            
            socket.emit('submit-vote', { gameCode, vote: playerId });
            
            // Update confirmation page based on vote type
            const confirmationEmoji = document.querySelector('.confirmation-emoji');
            const confirmationText = document.querySelector('.confirmation-text');
            
            if (isAnonymousVote) {
                // Anonymous vote
                confirmationEmoji.textContent = 'ü§ê';
                confirmationText.textContent = 'Your vote is secret this time!';
            } else {
                // Public vote
                confirmationEmoji.textContent = 'üëÄ';
                confirmationText.textContent = 'Everyone will see who you voted for!';
            }
            
            // Show confirmation (clear inline styles)
            document.getElementById('questionPage').classList.add('hidden');
            const confirmationPage = document.getElementById('confirmationPage');
            confirmationPage.classList.remove('hidden');
            confirmationPage.style.display = 'block';
            
            setTimeout(() => {
                confirmationPage.classList.add('hidden');
                
                const waitingPage = document.getElementById('waitingPage');
                waitingPage.classList.remove('hidden');
                // Clear ALL inline styles to show it properly
                waitingPage.style.display = '';
                waitingPage.style.visibility = '';
                waitingPage.style.opacity = '';
                
                document.getElementById('waitingText').textContent = 'Waiting for everyone else...';
                // Apply stored vote progress
                document.getElementById('waitingProgress').textContent = 
                    `${lastVoteProgress.voted}/${lastVoteProgress.total} voted`;
            }, 1000);
        }

        // Vote results
        socket.on('vote-results', (data) => {
            console.log('‚úÖ RESULTS RECEIVED:', data);
            
            // SET FLAG: Prevent any code from showing waiting page
            isShowingResults = true;
            
            // Step 1: NUCLEAR HIDE waiting page (before anything else)
            const waitingPage = document.getElementById('waitingPage');
            waitingPage.classList.add('hidden');
            waitingPage.style.display = 'none';
            waitingPage.style.visibility = 'hidden';
            waitingPage.style.opacity = '0';
            waitingPage.style.zIndex = '-9999';
            waitingPage.style.pointerEvents = 'none';
            
            // Step 2: Hide all pages
            document.querySelectorAll('.page').forEach(p => {
                p.classList.add('hidden');
                p.style.display = 'none';
            });
            
            // Reset waiting text for next question
            document.getElementById('waitingText').textContent = 'Waiting for everyone else...';
            document.getElementById('waitingProgress').textContent = '0/0 voted';
            
            // Step 3: Setup badge BEFORE showing results page
            const voteBadge = document.getElementById('voteBadgeResults');
            voteBadge.className = ''; // Clear all classes first
            
            if (data.isAnonymous === true) {
                // Anonymous vote
                voteBadge.className = 'anonymous-badge';
                voteBadge.innerHTML = 'üîí This vote was anonymous';
                console.log('üîí Anonymous badge set');
            } else {
                // Public vote
                voteBadge.className = 'public-badge';
                voteBadge.innerHTML = `
                    <div style="font-size: 1.1rem; font-weight: 700;">üîì This vote was public</div>
                    <div style="font-size: 0.85rem; margin-top: 4px; opacity: 0.9;">No secrets - everyone can see the votes!</div>
                `;
                console.log('üîì Public badge set');
            }
            
            // Step 4: Show results page LAST (after everything is setup)
            const resultsPage = document.getElementById('resultsPage');
            resultsPage.classList.remove('hidden');
            resultsPage.style.display = 'block';
            resultsPage.style.visibility = 'visible';
            resultsPage.style.opacity = '1';
            resultsPage.style.zIndex = '10';
            console.log('‚úÖ Results page visible');

            // Play success sound
            playSuccessSound();

            // Display results for both players
            const player1 = currentPlayers[0];
            const player2 = currentPlayers[1];
            
            const count1 = data.voteCounts[player1.id] || 0;
            const count2 = data.voteCounts[player2.id] || 0;
            
            const percent1 = data.totalVotes > 0 ? Math.round((count1 / data.totalVotes) * 100) : 0;
            const percent2 = data.totalVotes > 0 ? Math.round((count2 / data.totalVotes) * 100) : 0;

            document.getElementById('resultAvatar1').src = player1.photo;
            document.getElementById('resultName1').textContent = player1.name;
            document.getElementById('resultPercent1').textContent = percent1 + '%';
            document.getElementById('resultCount1').textContent = count1 + ' vote' + (count1 !== 1 ? 's' : '');

            document.getElementById('resultAvatar2').src = player2.photo;
            document.getElementById('resultName2').textContent = player2.name;
            document.getElementById('resultPercent2').textContent = percent2 + '%';
            document.getElementById('resultCount2').textContent = count2 + ' vote' + (count2 !== 1 ? 's' : '');

            // Show vote details if not anonymous
            if (!data.isAnonymous && Object.keys(data.voteDetails).length > 0) {
                document.getElementById('voteDetails').classList.remove('hidden');
                
                document.getElementById('votedForName1').textContent = player1.name;
                document.getElementById('votedForName2').textContent = player2.name;

                const voters1 = data.voteDetails[player1.id] || [];
                const voters2 = data.voteDetails[player2.id] || [];

                document.getElementById('voters1').innerHTML = voters1.map(v => `
                    <div class="voter-item">
                        <img src="${v.playerPhoto}" alt="${v.playerName}" class="voter-avatar">
                        <div class="voter-name">${v.playerName}</div>
                    </div>
                `).join('') || '<div style="opacity: 0.7;">No votes</div>';

                document.getElementById('voters2').innerHTML = voters2.map(v => `
                    <div class="voter-item">
                        <img src="${v.playerPhoto}" alt="${v.playerName}" class="voter-avatar">
                        <div class="voter-name">${v.playerName}</div>
                    </div>
                `).join('') || '<div style="opacity: 0.7;">No votes</div>';
            } else {
                document.getElementById('voteDetails').classList.add('hidden');
            }

            // Set status text based on admin or player
            const resultsStatusText = document.getElementById('resultsStatusText');
            if (isAdmin) {
                document.getElementById('nextQuestionBtn').classList.remove('hidden');
                resultsStatusText.textContent = "Everyone's waiting for the next question";
                resultsStatusText.style.color = 'rgba(255, 215, 0, 0.9)'; // Gold color for admin
            } else {
                resultsStatusText.textContent = "‚è≥ Waiting for admin to go to next question";
                resultsStatusText.style.color = 'rgba(255, 255, 255, 0.8)'; // White for players
            }
        });

        document.getElementById('nextQuestionBtn').addEventListener('click', () => {
            socket.emit('next-question', { gameCode });
            document.getElementById('nextQuestionBtn').classList.add('hidden');
        });

        // Show crush question (Spicy mode only)
        socket.on('show-crush-question', (data) => {
            isShowingResults = false; // Reset flag for crush question
            
            // Hide waiting page explicitly
            const waitingPage = document.getElementById('waitingPage');
            waitingPage.classList.add('hidden');
            waitingPage.style.display = 'none';
            
            document.querySelectorAll('.page').forEach(p => p.classList.add('hidden'));
            
            // Show crush page (clear inline styles)
            const crushPage = document.getElementById('crushPage');
            crushPage.classList.remove('hidden');
            crushPage.style.display = 'block';

            const crushOptions = document.getElementById('crushOptions');
            crushOptions.innerHTML = '';

            let selectedCrush = null;

            // Show opposite gender players
            data.options.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'voter-item';
                playerCard.style.cursor = 'pointer';
                playerCard.innerHTML = `
                    <img src="${player.photo}" alt="${player.name}" class="voter-avatar">
                    <div class="voter-name">${player.name}</div>
                `;

                playerCard.addEventListener('click', () => {
                    // Remove selection from all
                    crushOptions.querySelectorAll('.voter-item').forEach(item => {
                        item.style.border = 'none';
                        item.style.transform = 'scale(1)';
                    });

                    // Highlight selected
                    playerCard.style.border = '3px solid #6c3aed';
                    playerCard.style.transform = 'scale(1.1)';
                    selectedCrush = player.id;
                    document.getElementById('submitCrushBtn').disabled = false;
                });

                crushOptions.appendChild(playerCard);
            });

            // Submit crush
            document.getElementById('submitCrushBtn').onclick = () => {
                if (!selectedCrush) return;
                
                socket.emit('submit-crush', { gameCode, crushId: selectedCrush });
                document.getElementById('submitCrushBtn').disabled = true;
                document.getElementById('submitCrushBtn').textContent = '‚úì Submitted';
                
                // Show waiting
                document.getElementById('crushPage').classList.add('hidden');
                
                const waitingPage = document.getElementById('waitingPage');
                waitingPage.classList.remove('hidden');
                // Clear ALL inline styles to show it properly
                waitingPage.style.display = '';
                waitingPage.style.visibility = '';
                waitingPage.style.opacity = '';
                
                document.getElementById('waitingText').textContent = 'Waiting for everyone to vote...';
            };
        });

        // Game finished
        socket.on('game-finished', () => {
            // Hide waiting page explicitly
            const waitingPage = document.getElementById('waitingPage');
            waitingPage.classList.add('hidden');
            waitingPage.style.display = 'none';
            
            document.querySelectorAll('.page').forEach(p => p.classList.add('hidden'));
            const finishedPage = document.getElementById('finishedPage');
            finishedPage.classList.remove('hidden');
            finishedPage.style.display = 'block'; // Override inline display:none
        });

        // Play Again (Same Party)
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            if (!isAdmin) {
                showError('Only the admin can start a new game!');
                return;
            }
            socket.emit('play-again', { gameCode });
        });

        // New Party
        document.getElementById('newPartyBtn').addEventListener('click', () => {
            localStorage.removeItem('currentGameCode');
            socket.disconnect();
            window.location.href = '/menu.html';
        });

        // Listen for play again event
        socket.on('return-to-lobby', () => {
            window.location.href = '/lobby.html';
        });

        // Leave game
        document.getElementById('leaveGameBtn').addEventListener('click', () => {
            showConfirm('Are you sure you want to leave the game?', () => {
                socket.disconnect();
                localStorage.removeItem('currentGameCode');
                window.location.href = '/menu.html';
            });
        });

        // Listen for admin status
        socket.on('game-created', (data) => {
            isAdmin = data.game.adminId === socket.id;
        });

        socket.on('game-joined', (data) => {
            isAdmin = data.game.adminId === socket.id;
        });

        socket.on('new-admin', (data) => {
            isAdmin = data.adminId === socket.id;
        });
    </script>
</body>
</html>
